"""
Core data models for task orchestration
UPDATED: TaskRecord now stores the full Task for complete context
"""

from typing import Any, Dict, List, Literal, Optional
from datetime import datetime
from pydantic import Field

from app.models import CamelModel


ExecutionTarget = Literal["client", "server"]
FailurePolicy = Literal["abort", "continue", "retry"]
TaskStatus = Literal[
    "pending", "running", "completed", "failed", "waiting", "skipped", "emitted"
]


class LifecycleMessages(CamelModel):
    """Messages shown during task lifecycle"""
    on_start: Optional[str] = None
    on_success: Optional[str] = None
    on_failure: Optional[str] = None


class TaskControl(CamelModel):
    """Task execution control settings"""
    confidence: Optional[float] = None
    requires_approval: Optional[bool] = None
    approval_question: Optional[str] = None
    on_failure: FailurePolicy = "abort"
    timeout_ms: Optional[int] = None


class Task(CamelModel):
    """
    Immutable task definition generated by LLM
    Represents the PLAN, not execution state
    """

    task_id: str = Field(..., description="Unique task identifier")
    tool: str = Field(..., description="Tool name from tool_registry")
    execution_target: ExecutionTarget

    depends_on: List[str] = Field(
        default_factory=list,
        description="Task IDs this task depends on",
    )

    inputs: Dict[str, Any] = Field(
        default_factory=dict,
        description="Static input values",
    )

    input_bindings: Dict[str, str] = Field(
        default_factory=dict,
        description="JSONPath bindings to previous task outputs",
    )

    lifecycle_messages: Optional[LifecycleMessages] = None
    control: Optional[TaskControl] = None


class TaskOutput(CamelModel):
    """Standardized task execution output"""
    success: bool
    data: Dict[str, Any]
    error: Optional[str] = None


class TaskRecord(CamelModel):
    """
    Mutable task execution record

    ✅ STORES THE FULL TASK — client & server both get full context
    """

    # Immutable task definition
    task: Task = Field(..., description="Complete task definition from LLM")

    # Execution state
    status: TaskStatus = "pending"
    resolved_inputs: Dict[str, Any] = Field(
        default_factory=dict,
        description="Inputs after binding resolution",
    )
    output: Optional[TaskOutput] = None
    error: Optional[str] = None

    # Timing
    created_at: datetime = Field(default_factory=datetime.now)
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    duration_ms: Optional[int] = None

    # Client tracking
    emitted_at: Optional[datetime] = None
    ack_received_at: Optional[datetime] = None

    # ---- Helper properties (not serialized) ----
    @property
    def task_id(self) -> str:
        return self.task.task_id

    @property
    def tool(self) -> str:
        return self.task.tool

    @property
    def execution_target(self) -> ExecutionTarget:
        return self.task.execution_target

    @property
    def depends_on(self) -> List[str]:
        return self.task.depends_on

    @property
    def lifecycle_messages(self) -> Optional[LifecycleMessages]:
        return self.task.lifecycle_messages

    @property
    def control(self) -> Optional[TaskControl]:
        return self.task.control


class ExecutionState(CamelModel):
    """
    User execution state
    Tracks all tasks for a session
    """

    user_id: str
    tasks: Dict[str, TaskRecord] = Field(default_factory=dict)
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)

    def add_task(self, record: TaskRecord):
        self.tasks[record.task_id] = record
        self.updated_at = datetime.now()

    def get_task(self, task_id: str) -> Optional[TaskRecord]:
        return self.tasks.get(task_id)

    def get_task_output(self, task_id: str) -> Optional[TaskOutput]:
        task = self.tasks.get(task_id)
        return task.output if task else None

    def update_task_status(self, task_id: str, status: TaskStatus):
        task = self.tasks.get(task_id)
        if task:
            task.status = status
            self.updated_at = datetime.now()

    def get_tasks_by_status(self, status: TaskStatus) -> List[TaskRecord]:
        return [task for task in self.tasks.values() if task.status == status]

    def get_completed_task_ids(self) -> List[str]:
        return [
            task_id
            for task_id, task in self.tasks.items()
            if task.status == "completed"
        ]


class TaskBatch(CamelModel):
    """Batch of tasks to execute"""
    server_tasks: List[TaskRecord] = Field(default_factory=list)
    client_tasks: List[TaskRecord] = Field(default_factory=list)
